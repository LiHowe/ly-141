# 主程序模块使用指南

## 概述

本指南介绍如何在主程序中集成和使用模块系统，包括模块的注册、初始化、管理和监控。

## 系统集成

### 1. 在应用程序启动时初始化模块系统

在 `ApplicationInitializer.cs` 中添加模块初始化器：

```csharp
// MainApp/Initializers/ModuleInitializer.cs
using Core.Interfaces;
using Core.Services;
using Logger;

namespace MainApp.Initializers
{
    public class ModuleInitializer : IInitializer
    {
        public static string Name => "模块系统初始化";

        public static void Initialize()
        {
            try
            {
                // 创建模块管理器
                var moduleManager = new ModuleManager();
                
                // 注册到服务容器（如果使用DI容器）
                ServiceLocator.RegisterSingleton<IModuleManager>(moduleManager);
                
                // 发现并加载模块
                _ = Task.Run(async () =>
                {
                    await LoadModulesAsync(moduleManager);
                });
                
                Log.Info("[ModuleInitializer] 模块系统初始化完成");
            }
            catch (Exception ex)
            {
                Log.Error("[ModuleInitializer] 模块系统初始化失败", ex);
                throw;
            }
        }

        private static async Task LoadModulesAsync(IModuleManager moduleManager)
        {
            try
            {
                // 1. 发现模块
                var discoveryService = new ModuleDiscoveryService();
                var moduleLoader = new DynamicModuleLoader();
                
                var discoveredModules = await discoveryService.DiscoverModulesAsync("Modules");
                Log.Info($"[ModuleInitializer] 发现 {discoveredModules.Count} 个模块");

                // 2. 加载模块配置
                var configurations = await moduleLoader.LoadModuleConfigurationAsync("module-config.json");
                
                // 3. 注册模块
                foreach (var moduleInfo in discoveredModules)
                {
                    try
                    {
                        var module = await moduleLoader.LoadModuleAsync(moduleInfo);
                        if (module != null)
                        {
                            await moduleManager.RegisterModuleAsync(module);
                            Log.Info($"[ModuleInitializer] 成功注册模块: {module.ModuleName}");
                        }
                    }
                    catch (Exception ex)
                    {
                        Log.Error($"[ModuleInitializer] 注册模块失败: {moduleInfo.Name}", ex);
                    }
                }

                // 4. 初始化所有模块
                var initResult = await moduleManager.InitializeAllModulesAsync();
                Log.Info($"[ModuleInitializer] 模块初始化完成: 成功 {initResult.SuccessCount}, 失败 {initResult.FailedCount}");

                // 5. 启用所有模块
                var enableResult = await moduleManager.EnableAllModulesAsync();
                Log.Info($"[ModuleInitializer] 模块启用完成: 成功 {enableResult.SuccessCount}, 失败 {enableResult.FailedCount}");
            }
            catch (Exception ex)
            {
                Log.Error("[ModuleInitializer] 加载模块失败", ex);
            }
        }
    }
}
```

### 2. 创建模块配置文件

在主程序根目录创建 `module-config.json`：

```json
{
  "version": "1.0",
  "modules": [
    {
      "moduleId": "Module.Business.Repair",
      "name": "返修业务模块",
      "enabled": true,
      "priority": 100,
      "parameters": {
        "maxRetryCount": 3,
        "timeoutSeconds": 30
      },
      "database": {
        "enableDatabase": true,
        "autoCreateTables": true,
        "tablePrefix": "Repair"
      }
    },
    {
      "moduleId": "Module.Business.Weld",
      "name": "焊接业务模块", 
      "enabled": true,
      "priority": 200,
      "parameters": {
        "weldingTemperature": 250,
        "coolingTime": 10
      }
    }
  ]
}
```

### 3. 在主窗口中集成模块管理

```csharp
// MainApp/MainWindow.xaml.cs
public partial class MainWindow : Window
{
    private IModuleManager _moduleManager;

    public MainWindow()
    {
        InitializeComponent();
        _moduleManager = ServiceLocator.GetService<IModuleManager>();
        
        // 监听模块状态变化
        _moduleManager.ModuleStatusChanged += OnModuleStatusChanged;
        
        // 初始化模块相关UI
        InitializeModuleUI();
    }

    private void InitializeModuleUI()
    {
        // 创建模块管理界面
        var moduleManagementControl = new ModuleManagementControl(_moduleManager);
        
        // 添加到主界面
        ModuleContainer.Children.Add(moduleManagementControl);
    }

    private void OnModuleStatusChanged(object sender, ModuleStatusChangedEventArgs e)
    {
        Dispatcher.Invoke(() =>
        {
            // 更新UI状态
            UpdateModuleStatus(e.ModuleId, e.NewStatus);
            
            // 记录日志
            Log.Info($"模块 {e.ModuleId} 状态变更: {e.OldStatus} -> {e.NewStatus}");
        });
    }
}
```

## 模块管理界面

### 1. 创建模块管理控件

```csharp
// MainApp/Controls/ModuleManagementControl.xaml.cs
public partial class ModuleManagementControl : UserControl
{
    private readonly IModuleManager _moduleManager;
    private readonly ObservableCollection<ModuleViewModel> _modules;

    public ModuleManagementControl(IModuleManager moduleManager)
    {
        InitializeComponent();
        _moduleManager = moduleManager;
        _modules = new ObservableCollection<ModuleViewModel>();
        
        ModulesListView.ItemsSource = _modules;
        LoadModules();
    }

    private void LoadModules()
    {
        _modules.Clear();
        foreach (var module in _moduleManager.Modules)
        {
            _modules.Add(new ModuleViewModel(module, _moduleManager));
        }
    }

    private async void EnableModule_Click(object sender, RoutedEventArgs e)
    {
        if (sender is Button button && button.DataContext is ModuleViewModel moduleVM)
        {
            try
            {
                await _moduleManager.EnableModuleAsync(moduleVM.ModuleId);
                MessageBox.Show($"模块 {moduleVM.ModuleName} 已启用");
            }
            catch (Exception ex)
            {
                MessageBox.Show($"启用模块失败: {ex.Message}");
            }
        }
    }

    private async void DisableModule_Click(object sender, RoutedEventArgs e)
    {
        if (sender is Button button && button.DataContext is ModuleViewModel moduleVM)
        {
            try
            {
                await _moduleManager.DisableModuleAsync(moduleVM.ModuleId);
                MessageBox.Show($"模块 {moduleVM.ModuleName} 已禁用");
            }
            catch (Exception ex)
            {
                MessageBox.Show($"禁用模块失败: {ex.Message}");
            }
        }
    }
}

public class ModuleViewModel : INotifyPropertyChanged
{
    private readonly IModule _module;
    private readonly IModuleManager _moduleManager;

    public ModuleViewModel(IModule module, IModuleManager moduleManager)
    {
        _module = module;
        _moduleManager = moduleManager;
    }

    public string ModuleId => _module.ModuleId;
    public string ModuleName => _module.ModuleName;
    public string Version => _module.Version;
    public string Description => _module.Description;
    public bool IsEnabled => _module.IsEnabled;
    public ModuleStatus Status => _moduleManager.GetModuleStatus(_module.ModuleId);

    public event PropertyChangedEventHandler PropertyChanged;
}
```

### 2. 模块管理界面 XAML

```xml
<!-- MainApp/Controls/ModuleManagementControl.xaml -->
<UserControl x:Class="MainApp.Controls.ModuleManagementControl">
    <Grid>
        <Grid.RowDefinitions>
            <RowDefinition Height="Auto"/>
            <RowDefinition Height="*"/>
        </Grid.RowDefinitions>
        
        <!-- 标题栏 -->
        <Border Grid.Row="0" Background="{DynamicResource PrimaryBrush}" Padding="10">
            <TextBlock Text="模块管理" FontSize="16" FontWeight="Bold" Foreground="White"/>
        </Border>
        
        <!-- 模块列表 -->
        <ListView Grid.Row="1" x:Name="ModulesListView">
            <ListView.ItemTemplate>
                <DataTemplate>
                    <Border BorderBrush="{DynamicResource BorderBrush}" BorderThickness="1" 
                            Margin="5" Padding="10" CornerRadius="5">
                        <Grid>
                            <Grid.ColumnDefinitions>
                                <ColumnDefinition Width="*"/>
                                <ColumnDefinition Width="Auto"/>
                            </Grid.ColumnDefinitions>
                            
                            <StackPanel Grid.Column="0">
                                <TextBlock Text="{Binding ModuleName}" FontWeight="Bold" FontSize="14"/>
                                <TextBlock Text="{Binding Description}" Foreground="{DynamicResource TextIconBrush}"/>
                                <StackPanel Orientation="Horizontal" Margin="0,5,0,0">
                                    <TextBlock Text="版本: " FontWeight="Medium"/>
                                    <TextBlock Text="{Binding Version}"/>
                                    <TextBlock Text="状态: " FontWeight="Medium" Margin="20,0,0,0"/>
                                    <TextBlock Text="{Binding Status}"/>
                                </StackPanel>
                            </StackPanel>
                            
                            <StackPanel Grid.Column="1" Orientation="Horizontal">
                                <Button Content="启用" Click="EnableModule_Click" 
                                        IsEnabled="{Binding IsEnabled, Converter={StaticResource InverseBooleanConverter}}"
                                        Margin="5,0"/>
                                <Button Content="禁用" Click="DisableModule_Click" 
                                        IsEnabled="{Binding IsEnabled}"
                                        Margin="5,0"/>
                            </StackPanel>
                        </Grid>
                    </Border>
                </DataTemplate>
            </ListView.ItemTemplate>
        </ListView>
    </Grid>
</UserControl>
```

## 模块动态加载

### 1. 运行时加载新模块

```csharp
public async Task<bool> LoadModuleFromFileAsync(string modulePath)
{
    try
    {
        var moduleLoader = new DynamicModuleLoader();
        var moduleInfo = new ModuleInfo
        {
            Name = Path.GetFileNameWithoutExtension(modulePath),
            AssemblyPath = modulePath
        };

        var module = await moduleLoader.LoadModuleAsync(moduleInfo);
        if (module != null)
        {
            await _moduleManager.RegisterModuleAsync(module);
            await _moduleManager.InitializeModuleAsync(module.ModuleId);
            await _moduleManager.EnableModuleAsync(module.ModuleId);
            
            Log.Info($"成功加载模块: {module.ModuleName}");
            return true;
        }
    }
    catch (Exception ex)
    {
        Log.Error($"加载模块失败: {modulePath}", ex);
    }
    
    return false;
}
```

### 2. 卸载模块

```csharp
public async Task<bool> UnloadModuleAsync(string moduleId)
{
    try
    {
        await _moduleManager.DisableModuleAsync(moduleId);
        await _moduleManager.UnregisterModuleAsync(moduleId);
        
        Log.Info($"成功卸载模块: {moduleId}");
        return true;
    }
    catch (Exception ex)
    {
        Log.Error($"卸载模块失败: {moduleId}", ex);
        return false;
    }
}
```

## 模块通信

### 1. 事件总线集成

```csharp
// MainApp/Services/ModuleEventBus.cs
public class ModuleEventBus
{
    private readonly Dictionary<string, List<Action<object>>> _eventHandlers = new();

    public void Subscribe(string eventName, Action<object> handler)
    {
        if (!_eventHandlers.ContainsKey(eventName))
        {
            _eventHandlers[eventName] = new List<Action<object>>();
        }
        _eventHandlers[eventName].Add(handler);
    }

    public void Publish(string eventName, object eventData)
    {
        if (_eventHandlers.TryGetValue(eventName, out var handlers))
        {
            foreach (var handler in handlers)
            {
                try
                {
                    handler(eventData);
                }
                catch (Exception ex)
                {
                    Log.Error($"处理事件 {eventName} 失败", ex);
                }
            }
        }
    }
}
```

### 2. 在主程序中监听模块事件

```csharp
public void InitializeModuleEventHandling()
{
    var eventBus = ServiceLocator.GetService<ModuleEventBus>();
    
    // 监听数据更新事件
    eventBus.Subscribe("DataUpdated", (data) =>
    {
        // 更新UI或执行其他操作
        Dispatcher.Invoke(() => RefreshDataDisplay());
    });
    
    // 监听系统状态变化
    eventBus.Subscribe("SystemStatusChanged", (data) =>
    {
        // 处理系统状态变化
        HandleSystemStatusChange(data);
    });
}
```

## 配置管理

### 1. 动态配置更新

```csharp
public async Task UpdateModuleConfigurationAsync(string moduleId, Dictionary<string, object> newParameters)
{
    try
    {
        var module = _moduleManager.GetModule(moduleId);
        if (module?.Configuration != null)
        {
            // 更新配置参数
            foreach (var param in newParameters)
            {
                module.Configuration.Parameters[param.Key] = param.Value;
            }
            
            // 保存配置
            await SaveModuleConfigurationAsync(module.Configuration);
            
            // 通知模块配置已更新
            if (module is ModuleBase moduleBase)
            {
                await moduleBase.OnConfigurationChangedAsync();
            }
        }
    }
    catch (Exception ex)
    {
        Log.Error($"更新模块配置失败: {moduleId}", ex);
    }
}
```

### 2. 配置持久化

```csharp
private async Task SaveModuleConfigurationAsync(ModuleConfiguration configuration)
{
    var configPath = Path.Combine("Config", $"{configuration.ModuleId}.json");
    var json = JsonSerializer.Serialize(configuration, new JsonSerializerOptions
    {
        WriteIndented = true,
        PropertyNamingPolicy = JsonNamingPolicy.CamelCase
    });
    
    await File.WriteAllTextAsync(configPath, json);
}
```

## 监控和诊断

### 1. 模块健康检查

```csharp
public async Task<Dictionary<string, bool>> PerformHealthCheckAsync()
{
    var results = new Dictionary<string, bool>();
    
    foreach (var module in _moduleManager.Modules)
    {
        try
        {
            var isHealthy = await CheckModuleHealthAsync(module);
            results[module.ModuleId] = isHealthy;
        }
        catch (Exception ex)
        {
            Log.Error($"模块健康检查失败: {module.ModuleId}", ex);
            results[module.ModuleId] = false;
        }
    }
    
    return results;
}

private async Task<bool> CheckModuleHealthAsync(IModule module)
{
    // 检查模块状态
    if (!module.IsEnabled) return false;
    
    // 检查数据库连接（如果模块使用数据库）
    if (module is ModuleBase moduleBase && moduleBase.IsDatabaseInitialized)
    {
        return moduleBase.IsDatabaseConnectionAvailable();
    }
    
    return true;
}
```

### 2. 性能监控

```csharp
public class ModulePerformanceMonitor
{
    private readonly Dictionary<string, PerformanceCounter> _counters = new();
    
    public void StartMonitoring(string moduleId)
    {
        var counter = new PerformanceCounter();
        _counters[moduleId] = counter;
        
        // 定期收集性能数据
        var timer = new Timer(async _ =>
        {
            await CollectPerformanceDataAsync(moduleId);
        }, null, TimeSpan.Zero, TimeSpan.FromMinutes(1));
    }
    
    private async Task CollectPerformanceDataAsync(string moduleId)
    {
        // 收集CPU、内存等性能指标
        var cpuUsage = GetCpuUsage();
        var memoryUsage = GetMemoryUsage();
        
        // 记录到日志或数据库
        Log.Info($"模块 {moduleId} 性能: CPU={cpuUsage}%, Memory={memoryUsage}MB");
    }
}
```

## 最佳实践

### 1. 错误处理和恢复

```csharp
public async Task HandleModuleErrorAsync(string moduleId, Exception error)
{
    Log.Error($"模块 {moduleId} 发生错误", error);
    
    try
    {
        // 尝试重启模块
        await _moduleManager.DisableModuleAsync(moduleId);
        await Task.Delay(1000); // 等待清理完成
        await _moduleManager.EnableModuleAsync(moduleId);
        
        Log.Info($"模块 {moduleId} 重启成功");
    }
    catch (Exception ex)
    {
        Log.Error($"模块 {moduleId} 重启失败", ex);
        
        // 标记模块为故障状态
        await MarkModuleAsFaultedAsync(moduleId);
    }
}
```

### 2. 优雅关闭

```csharp
public async Task ShutdownApplicationAsync()
{
    Log.Info("开始关闭应用程序...");
    
    try
    {
        // 1. 禁用所有模块
        await _moduleManager.DisableAllModulesAsync();
        
        // 2. 等待模块完成清理
        await Task.Delay(2000);
        
        // 3. 卸载所有模块
        await _moduleManager.UnregisterAllModulesAsync();
        
        Log.Info("应用程序关闭完成");
    }
    catch (Exception ex)
    {
        Log.Error("应用程序关闭过程中发生错误", ex);
    }
}
```

### 3. 资源管理

```csharp
public void Dispose()
{
    try
    {
        // 清理模块管理器
        _moduleManager?.Dispose();
        
        // 清理事件总线
        _eventBus?.Dispose();
        
        // 清理其他资源
        _performanceMonitor?.Dispose();
    }
    catch (Exception ex)
    {
        Log.Error("资源清理失败", ex);
    }
}
```

通过以上指南，您可以在主程序中完整地集成和管理模块系统，实现动态加载、配置管理、监控诊断等企业级功能。
